<!doctype html>
<html lang="en-us">

<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <style>
    body {
      font-family: Arial;
      font-weight: bold;
      text-align: center;
    }

    #image-container {
      margin-top: 20px;
      margin-bottom: 20px;
    }

    .slider {
      width: 50%;
    }
  </style>
</head>

<body>

  <div id="slidecontainer">
    <input type="range" min="1" max="100" value="1" class="slider" id="quality">
  </div>
  <div id="image-container">
  </div>
  <div id="size"></div>

  <script async type="text/javascript" src="webassembly-jpeg.js"></script>
  <script>

    // Module is our Web Assembly instance
    var Module = {
      // When the instance has been loaded and compiled...
      onRuntimeInitialized: () => {

        // JS wrap of : Image* setSrcImage(BYTE* jpegData, ULONG size)
        let setSrcImage = Module.cwrap('setSrcImage', 'number', ['number', 'number']);
        // JS wrap of : Image* compress(ULONG quality)
        let compress = Module.cwrap('compress', 'number', ['number']);
        // Canvas
        let displayZone = {
          ctx: undefined,       // canvas context
          imageData: undefined  // internal canvas bitmap data
        };
        // The following object maps the C Image structure
        let image = {
          width: undefined,
          height: undefined,
          compressedSize: undefined,
          data: undefined
        }

        // Start point...
        loadSrcImage("kuva.jpg");

        function loadSrcImage(imgUrl) {
          fetch(imgUrl)
            .then(response => response.arrayBuffer())
            .then(initImage)
            .then(createDisplayZone)
            .then(() => update(1));
        }

        function initImage(rawJpeg) {
          // the fetch response is an ArrayBuffer (not typed).
          // We create a typed array from it.
          let rawJpegAsTypedArray = new Uint8Array(rawJpeg);
          // We allocate a memory block inside our WebAssembly module using the libc malloc function
          // given by the emscripten glue code.
          let srcBuf = Module._malloc(rawJpegAsTypedArray.length * rawJpegAsTypedArray.BYTES_PER_ELEMENT);
          // We copy the typed array to the memory block
          // Important : this memory block is a part of the heap. 
          // The heap is allocated by JS code in the Emscripten glue and 
          // given as the memory to the WebAssembly instance.
          // So, when we do malloc we simply get an index into the heap where 
          // we can write. This is done by writeArrayToMemory which will
          // simply call HEAP8.set(array, buffer), which means : 
          // "copy array to HEAP8 at offset buffer"
          Module.writeArrayToMemory(rawJpegAsTypedArray, srcBuf);
          // We give setSrcImage the pointer to the raw Jpeg data in the heap.
          // This function will return information about the bitmap :
          // { ULONG width; ULONG height; ULONG compressedSize; BYTE* bmpData; }
          let pImage = setSrcImage(srcBuf, rawJpegAsTypedArray.length);
          // We get width and height from these informations
          image.width = Module.getValue(pImage + 0, 'i32');
          image.height = Module.getValue(pImage + 4, 'i32');
          // console.log("Size wil be ", image.width, "x", image.height);
          // We known our WebAssembly code will not use anymore the allocated memory block.
          Module._free(srcBuf);
          // And we will not need the raw data anymore.
          delete rawJpegAsTypedArray;
        }

        function createDisplayZone() {
          let canvas = document.createElement('canvas');
          canvas.width = image.width;
          canvas.height = image.height;
          document.getElementById('image-container').appendChild(canvas);
          displayZone.ctx = canvas.getContext('2d');
          displayZone.imageData = displayZone.ctx.createImageData(image.width, image.height);
        }

        function display() {
          // It's a view, so we can write 32 bit at a time
          let len = image.width * image.height
          let buf32 = new Uint32Array(displayZone.imageData.data.buffer, 0, len)
          // Alpha, opaque
          let alpha = 0xff000000

          // Copy directly from the module memory to imageData
          // read from view of wasm image.data as Uint32 array
          let source = new Uint32Array(Module.HEAP8.buffer, image.data, len / 4 * 3)

          // read 3 int, write 4 per loop, assumes len is a multiple of 4
          for (let iSrc = 0, iDst = 0; iDst < len; iSrc += 3, iDst += 4) {
              let bytes = source[iSrc];
              buf32[iDst] = bytes | alpha;
              let next = bytes >>> 24; // R
              bytes = source[iSrc + 1]
              buf32[iDst + 1] = next | bytes << 8 | alpha;
              next = bytes >>> 16; // GR
              bytes = source[iSrc + 2]
              buf32[iDst + 2] = next | bytes << 16 | alpha;
              buf32[iDst + 3] = bytes >>> 8 | alpha;
          }

          displayZone.ctx.putImageData(displayZone.imageData, 0, 0);
        }

        // On slider move...
        function update(quality) {
          // Call the WebAssembly function compress()
          // It will compress the bitmap image to Jpeg with given quality value.
          // Then it will decompress back and return the bitmap structure (width, height, uncompressedSize, data)
          let pImage = compress(quality);
          image.compressedSize = getValue(pImage + 8, 'i32');
          image.data = getValue(pImage + 12, 'i32');
          document.getElementById('size').innerHTML = 'Quality:' + quality + ' / Weight: ' + (image.compressedSize / 1024).toFixed(2) + ' Kb';
          // Show it to the world
          display();
          // The display function has copied the bitmap data to the canvas through
          // an Uint8Array. Si, we do not need the bitmap structure anymore.
          Module._free(image.data);
          Module._free(pImage);
        }

        let slider = document.getElementById("quality");
        slider.oninput = function () {
          update(this.value);
        };
      }
    };
  </script>
</body>

</html>
